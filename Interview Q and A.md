:::::::::::::::::::::::::::::::::::::::::: Interview Q and A ::::::::::::::::::::::::::::::::::::::::::

- **Tell me about yourself:**
- I prince Kumar, I am working with .Net Core technologies from past 1 year. In that period, I was working as a junior Developer in a team where I was working in a Project based on API. In that project, my responsibility was to maintain user interaction in the UI Layer. I also define some dependencies in Program.cs class and Startup.cs class.
- In UI layer we set the status code according to the application requirement. Along with this I also worked on service layer where I have to deal with DI and resolve the dependencies by using Constructor.

- Actually, I join the company as a student to learn the backend technology, after 3 month they ask me to work with them as an intern and they ensure me to it will be a permanent role after couple month. so, I work there as an intern for almost 3 months after that I start working as a full-time employee.


- **Questions extracted from the Interview Experience**
- *C# OOPS*

- ***MVC***
- Filter and type of filter the ASP.Net Core MVC Application
- ***Web API***

- ***SQL SERVER***
- Difference Between Union and Union all.
- Function in SQL server.
- Deference between function and stored procedure
- Trigger.
- Index, Clustering and non-Clustering.
- Syntax to create stored procedure
- Write a query to insert two new records into the table.
- INSERTINTO Query.
- WHERE clause.
- Indexing in stored procedure.


**Question**

#### Question 1 :- Explain difference between .NET and C# ?
#### Question 2 :- .NET Framework vs .NET Core vs .NET 5.0
#### Question 3 :- What is IL ( Intermediate Language) Code ?
#### Question 4 :- What is the use of JIT ( Just in time compiler) ?
#### Question 5 :- Is it possible to view IL code ?
#### Question 6 :- What is the benefit of compiling in to IL code ?
#### Question 7 :- Does .NET support multiple programming languages ?
#### Question 8 :- What is CLR ( Common Language Runtime) ?
#### Question 9 :- What is managed and unmanaged code ?
#### Question 10 :- Explain the importance of Garbage collector ?
#### Question 11 :- Can garbage collector claim unmanaged objects ?
#### Question 12 :- What is the importance of CTS ?
#### Question 13 :- Explain CLS ?
#### Question 14 :- Difference between Stack vs Heap ?
#### Question 15 :- What are Value types & Reference types?
#### Question 16 :- Explain boxing and unboxing ?
#### Question 17 :- What is consequence of boxing and unboxing ?
#### Question 18 :- Explain casting, implicit casting and explicit casting ?
#### Question 19 :- What can happen during explicit casting ?
#### Question 20 :- Differentiate between Array and ArrayList ?
#### Question 21 :- Whose performance is better array or ArrayList ?
#### Question 22 :- What are generic collections ?
#### Question 23 :- What are threads (Multithreading)?
#### Question 24 :- How are threads different from TPL ?
#### Question 25 :- How do we handle exceptions in C#(try/catch)?
#### Question 26 :- What is the need of finally?
#### Question 27 :- Why do we need the out keyword ?
#### Question 28 :- What is the need of Delegates ?
#### Question 29 :- What are events ?
#### Question 30 :- What’s the difference between Abstract class and interface ?
#### Question 31 - What is a Delegate and how to create a Delegate?
#### Question 32 - Where have you used Delegates?
#### Question 33 - What is a Multicast Delegates?
#### Question 34 - What is an Event?
#### Question 35 - How to Create an Event?
#### Question 36 - Delegate VS Events.
#### Question 37 :- Why do we need OOP ?
#### Question 38 :- What are the important pillars of OOPs ?
#### Question 39 :- What is a class and object ?
#### Question 40 :- Abstraction vs Encapsulation?
#### Question 41 :- Explain Inheritance ?
#### Question 42 :- Explain virtual keyword ?
#### Question 43 :- What is overriding ?
#### Question 44 :- Explain overloading ?
#### Question 45 :- Overloading vs Overriding ?
#### Question 46 :- Explain static vs dynamic polymorphism ?
#### Question 47 :- Explain operator overloading ?
#### Question 48 :- Why do we need Abstract classes ?
#### Question 49 :- Are Abstract methods virtual ?
#### Question 50 :- Can we create a instance of Abstract classes ?
#### Question 51 :- Is it compulsory to implement Abstract methods ?
#### Question 52 :- Why simple base class replace Abstract class ?
#### Question 53 :- Explain interfaces and why do we need it ?
#### Question 54 :- Can we write logic in interface ?
#### Question 55 :- Can we define methods as private in interface ?
#### Question 56 :- If i want to change interface what’s the best practice ?
#### Question 59 :- Explain Multiple inheritance in Interface ?
#### Question 60 :- Explain Interface Segregation principle ?
#### Question 61 :- Can we create instance of interface ?
#### Question 62 :- Can we do Multiple inheritance with Abstract classes ?
#### Question 63 :- Abstract Class vs interface interview questions and answers.
#### Question 64 :- Why do we need constructors ?
#### Question 65 :- In parent child which constructor fires first ?
#### Question 66 :- How are initializers executed ?
#### Question 67 :- How are static constructors executed in Parent child ?
#### Question 68 :- When does static constructor fires ?
#### Question 69 :- What is Shadowing?
#### Question 70 :- Explain method hiding?
#### Question 71 :- Shadowing vs Overriding ?
#### Question 72 :- When do we need Shadowing ?
#### Question 73 :- Explain Sealed Classes ?
#### Question 74 :- Can we create instance of sealed classes ?
#### Question 75 :- What are nested classes and when to use them ?
#### Question 76 :- Can Nested class access outer class variables ?
#### Question 77 :- Can we have public, protected access modifiers in nested class ?
#### Question 78 :- Explain Partial classes ?
#### Question 79 :- In What scenarios do we use partial classes ?
#### Question 80 :- What is SOLID ?
#### Question 81 :- What is the full form of SOLID ?
#### Question 82 :- What is the goal of SOLID ?
#### Question 83 :- Explain SRP with A example ?
#### Question 84 :- What is the benefit of SRP ?
#### Question 85 :- Explain OCP with a example ?
#### Question 86 :- What is the benefit of OCP ?
#### Question 87 :- Can you explain LISKOV Principle and it's violation?
#### Question 88 :- How can we fix LISKOV Problem ?
#### Question 89 :- Explain Interface Segregation Principle ?
#### Question 90 :- Is there a connection between LISKOV and ISP ?
#### Question 91 :- Define dependency inversion ?
#### Question 92 :- What is higher level module and lower level module ?
#### Question 93 :- How does dependency inversion benefit, show with an example ?
#### Question 94 :- Will only Dependency inversion solve decoupling problem ?
#### Question 95 :- Why do developers move object creation outside high lever module ?
#### Question 96 :- Explain IOC ( Inversion of Control) ?
#### Question 97 :- Explain Dependency Injection with an example ?
#### Question 98 :- Is SOLID, IOC and DI design pattern or Principle?
#### Question 99 :- Is only SOLID Enough for good code/ architecture ?
#### Question 100 :- What are the different types of "USING/HAS A" relationship ?
#### Question 101 :- What is a composition relationship ?
#### Question 102 :- Explain Aggregation ?
#### Question 103 :- Explain Association ?
#### Question 104 :- Differentiate between Composition vs Aggregation vs Association ?
#### Question 105 :- UML Symbols for Composition, Aggregation and Association
#### Question 106 :- Explain stack and Heap ?
#### Question 107 :- Where are stack and heap stored ?
#### Question 108 :- What goes on stack and what goes on heap ?
#### Question 109 :- How is the stack memory address arranged ?
#### Question 110 :- How is stack memory deallocated LIFO or FIFO ?
#### Question 111 :- How are primitive and objects stored in memory?
#### Question 112 :- Can primitive data types be stored in heap ?
#### Question 113 :- Explain value types and reference types ?
#### Question 114 :- Explain byvalue and byref ?
#### Question 115 :- Differentiate between copy byvalue and copy byref ?
#### Question 116 :- What is boxing and unboxing ?
#### Question 117 :- Is boxing unboxing good or bad ?
#### Question 118 :- Can we avoid boxing and unboxing ?
#### Question 119 :- What effect does boxing and unboxing have on performance ?
#### Question 120 :- Are string allocated on stack or heap ?
#### Question 121 :- How many stack and heaps are created for an application ?
#### Question 122 :- How are stack and heap memory deallocated ?
#### Question 123 :- Who clears the heap memory ?
#### Question 124 :- Where is structure allocated Stack or Heap ?
#### Question 125 :- Are structures copy byvalue or copy byref ?
#### Question 126 :- Can structures get created on Heap ?
#### Question 127: - Explain Garbage collector (GC)?
#### Question 128:- How does Garbage collector know when to clean the objects ?
#### Question 129 :- Is there a way we can see this Heap memory ?
#### Question 130 :- Does Garbage collector clean primitive types ?
#### Question 131: - Managed vs UnManaged code/objects/resources?
#### Question 132:- Can garbage collector clean unmanaged code ?
#### Question 133:- Explain Generations ?
#### Question 134:- What is GC0,GC1, and GC2 ?
#### Question 135:- Why do we need Generations ?
#### Question 136:- Which is the best place to clean unmanaged objects ?
#### Question 137:- How does GC behave when we have a destructor ?
#### Question 138:- What do you think about empty destructor ?
#### Question 139:- Explain the Dispose Pattern?
#### Question 140 :- Finalize vs Destructor ?
#### Question 141:- What is the use of using keyword ?
#### Question 142:- Can you force Garbage collector ?
#### Question 143:- Is it a good practice to force GC ?
#### Question 144:- How can we detect a memory issues ?
#### Question 145:- How can we know the exact source of memory issues ?
#### Question 146 :- What is a memory leak ?
#### Question 147 :- Can .NET Application have memory leak as we have GC?
#### Question 148:- How to detect memory leaks in .NET applications ?
#### Question 149:- Explain weak and strong references ?
#### Question 150 :- When will you use weak references ?




**MVC**

#### Question 1 :- What is ASP .NET MVC Core ?
#### Question 2 :- Differentiate between ASP .NET Webforms vs MVC vs MVC core ?
#### Question 3 :- Explain MVC Architecture ?
#### Question 4 :- Why do we have wwwroot folder ?
#### Question 5 :- Explain the importance of appsettings.json ?
#### Question 6 :- How to read configurations from appsettings.json ?
#### Question 7 :- What is dependency injection ?
#### Question 8 :- Why do we need dependency injection ?
#### Question 9 :- How do we implement dependency injection ?
#### Question 10 :- What is the use of Middleware ?
#### Question 11 :- How to create a Middle ware ?
#### Question 12 :- What does startup.cs file do ?
#### Question 13 :- ConfigureServices vs Configure method ?
#### Question 14 :- Explain the different Ways of doing DI?
#### Question 15 :- Explain Scoped vs Transient vs Singleton ?
#### Question 16 :- What is Razor ?
#### Question 17 :- How to pass Model data to a View ?
#### Question 18 :- What is the use of Strongly typed views ?
#### Question 19 :- Explain the concept of ViewModel in MVC ?
#### Question 20 :- What is Kestrel Web Server ?
#### Question 21 :- Why Kestrel when we have IIS server ?
#### Question 22 :- What is the concept of Reverse proxy ?
#### Question 23 :- What are cookies ?
#### Question 24 :- What is the need session management ?
#### Question 25 :- What are the various ways of doing Session management in ASP.NET ?
#### Question 26 :- What exactly is a session ?
#### Question 27 :- Explain "HTTP is a stateless protocol" ?
#### Question 28 :- What are various way of doing session management ?
#### Question 29 :- Are sessions enabled by default ?
#### Question 30 :- How to enable sessions in MVC core ?
#### Question 31 :- Are sessions variables shared(global) between users ?
#### Question 32 :- Do session variables use cookies ?
#### Question 33 :- What is a cookie ?
#### Question 34 :- Explain idle time out in sessions ?
#### Question 35 :- What does a Context means in HTTP ?
#### Question 36 :- When should we use viewdata ?
#### Question 37 :- How to pass data from controller to view ?
#### Question 38 :- In same request can viewdata persist across actions ?
#### Question 39 :- ViewData vs ViewBag
#### Question 40 :- How does ViewBag work internally?
#### Question 41 :- Explain ViewModel?
#### Question 42 :- ViewBag vs ViewModel what’s the best practice?
#### Question 43 :- Explain TempData ?
#### Question 44 :- Can TempData persist across action redirects ?
#### Question 45 :- How is TempData different from viewdata ?
#### Question 46 :- If TempData is read is it available for next request ?
#### Question 47 :- How to persist TempData ?
#### Question 48 :- What does Keep do in TempData ?
#### Question 49 :- Explain Peek in TempData ?
#### Question 50 :- How is TempData different from session variables ?
#### Question 51 :- If I restart the server does TempData, session stay ?
#### Question 52 :- Is TempData private to a user ?
#### Question 53 :- ViewData vs ViewBag vs TempData vs Session variables?
#### Question 54 :- What is WebAPI ?
#### Question 55 :- What is the advantage of WebAPI ?
#### Question 56 :- Explain REST and Architectural constraints of REST?
#### Question 57 :- Can we use TCPIP protocol with Web API?
#### Question 58 :- How WebAPI different from MVC controller ?
#### Question 59 :- What is content negotiations in Web API ?
#### Question 60 :- WebAPI vs WCF ?
#### Question 61 :- WCF REST vs WebAPI REST ?
#### Question 62 :- How to return HTTP status codes ?
#### Question 63 :- For error which status code is returned ?
#### Question 64 :- How did you secure your web API ?
#### Question 65 :- How do current JS frameworks work with WebAPI ?
#### Question 66 :- How does Token based Authentication works?
#### Question 67 :- Why is it called JWT Token?
#### Question 68 :- Explain the 3 sections of JWT Token?
#### Question 69 :- What are Identity and claims ?
#### Question 70 :- Differentiate between Authentication VS Authorization ?
#### Question 71 : Claims vs Roles ?
#### Question 72 :- Principal vs Identity
#### Question 73 :- Can we put critical information in JWT Token ?
#### Question 74 :- How do you create JWT Token in MVC ?
#### Question 75 :- What HTTP status code do you send for unauthorized access ?
#### Question 76 :- Where is Token Checked in ASP.NET MVC ?
#### Question 77 :- What is use of Authorize Attribute ?
#### Question 78 :- How did you implement JWT token security ?
#### Question 79 :- How do we send tokens from Client Side ?
#### Question 80 :- From JavaScript,  jQuery, Angular etc , how is token passed ?
#### Question 81 :- Increase UX experience in Mobile apps to avoid re-login ?
#### Question 82 :- What are refresh tokens ?
#### Question 83 :- How does Refresh token work ?
#### Question 84 :- Access tokens vs Refresh Tokens ?
#### Question 85 :- Whose expiry time is more Access tokens or Refresh tokens?
#### Question 86 :- Explain revocation of Refresh token ?
#### Question 87 :- How to extract Principal from a Token ?
#### Question 88 :- What is the best practice to store tokens at client side?
#### Question 89 :- If we store JWT in cookie how to save from XX attacks?
#### Question 90 :- What OAUTH and OpenID ?
#### Question 91 :- When should we use what?
#### Question 92 :- What is Identity Server?
#### Question 93 :- How to achieve single sign on ?
#### Question 94 :- What are scopes in Identity Server ?



**SQL**


#### Question 1 :- Explain normalization ?
#### Question 2 :- How to implement normalization ?
#### Question 3 :- What is denormalization ?
#### Question 4 :- Explain OLTP vs OLAP ?
#### Question 5 :- Explain 1st,2nd and 3rd Normal form ?
#### Question 6 :- Primary Key vs Unique key ?
#### Question 7 :- Differentiate between Char vs Varchar ?
#### Question 8 :- Differentiate between Char vs NChar ?
#### Question 9 :- What’s the size of Char vs NChar ?
#### Question 10 :- What is the use of Index ?
#### Question 11 :- How does it make search faster?
#### Question 12 :- What are the two types of Indexes ?
#### Question 13 :- Clustered vs non-clustered index?
#### Question 14 :- Function vs Stored Procedures?
#### Question 15 :- What are triggers and why do you need it ?
#### Question 16 :- What are types of triggers ?
#### Question 17 :- Differentiate between After trigger vs Instead Of ?
#### Question 18 :- What is need of Identity ?
#### Question 19 :- Explain transactions and how to implement it ?
#### Question 20 :- What are inner joins ?
#### Question 21 :- Explain Left join ?
#### Question 22 :- Explain Right join ?
#### Question 23 :- Explain Full outer joins ?
#### Question 24 :- Explain Cross joins ?
#### Question 25 :- Why do we need UNION ?
#### Question 26 :- Differentiate between Union vs Union All ?
#### Question 27 :- Can we have unequal columns in Union?
#### Question 28 :- Can column have different data types in Union ?
#### Question 29 :- Which Aggregate function have you used ?
#### Question 30 :- When to use Group by ?
#### Question 31 :- Can we select column which is not part of group by ?
#### Question 32 :- What is having clause ?
#### Question 33 :- Having clause vs Where clause?
#### Question 34 :- How can we sort records ?
#### Question 35 :- What’s the default sort ?
#### Question 36 :- How can we remove duplicates ?
#### Question 37 :- Select the first top X records ?
#### Question 38 :- How to handle NULLS ?
#### Question 39 :- What is use of wild cards ?
#### Question 40 :- What is the use of Alias ?
#### Question 41 :- How to write a case statement ?
#### Question 42 :- What is self-reference tables ?
#### Question 43 :- What is self-join ?
#### Question 44 :- Explain the between clause ?
#### Question 45 :- Explain Subquery ?
#### Question 46 :- Can inner Subquery return multiple results ?
#### Question 47 :- What is Co-related Query ?
#### Question 48 :- Differentiate between Joins and Subquery ?
#### Question 49 :- Performance Joins vs Subquery?
#### Question 50 :- Find NTH Highest Salary in SQL.
#### Question 51 :- Select the top nth highest salary using correlated Queries?
#### Question 52 :- Select top nth using TSQL
#### Question 53 :- Performance comparison of all the methods.

## C# & OOPs Interview Question and Answer

1. What is COM (Component Object Model):
- It is one of the Microsoft’s technologies where we can develop applications as well as web applications.

In earlier COM, VB (programming language) was used to implement Windows applications and ASP for Web applications.

- Disadvantage:
1. Incomplete OOP, will not support all the features of OOPs.
1. Platform dependent, COM application can run on only Windows OS.
1. What .Net represents:

   Stands for Network Enabled technology. And.(Dot) refers to object-oriented and NET refers to the internet. So.NET means through object-oriented we can implement internet applications.

1. What is Framework:

   A framework is software. Or we can say that a framework is a collection of many small technologies integrated together to develop applications that can be executed anywhere.

1. What .Net framework provide:

   .NET Framework provides two things such as.

   1. BCL(Base class library):
- It is designed by Microsoft and installed into the machine when we install the .NET, Without BCL we can’t write any code in .NET so BCL was also known as the building block of Programs of . NET.
- it contains predefined classes and interfaces that are used for the purpose of application development.
  1. CLR (Common language runtime):

![](Aspose.Words.9cf1ec20-9144-491c-9ab1-78849ae8fa06.001.png)

- First, the developer has to write the code using any dot net-supported programming languages such as C#, VB, J#, etc.
- Then the respective language compiler will compile the source code and generate something called Microsoft Intermediate Language (MSIL) or Intermediate Language (IL) code. For example, if the programming language is C#, then the compiler is CSC and if the programming language is VB, then the compiler will be VBC. 
- This Intermediate Language (IL) code is half-compiled code i.e., partially compiled code, and cannot be executed directly by the Operating System. 
- To execute this Microsoft Intermediate Language (MSIL) or Intermediate Language (IL) code on our machine.
- The .NET Framework provides something called Common Language Runtime (CLR) which takes the responsibility to execute our Microsoft Intermediate Language (MSIL) or Intermediate Language (IL) Code.
- The CLR takes the IL (Intermediate Language) code and gives it to something called the JIT (Just-in-Time) Compiler which is part of the CLR. 
- The JIT compiler reads each and every line of the IL code and converts it to machine-specific instructions (i.e., into binary format) which will be executed by the underlying Operating System. 
- The CLR in .NET Framework provides the runtime environment to execute the .NET Applications.</p>
- IL code: 
- It is partially compiled code, why partially compiled? Because we don’t know what kind of environment .NET code is going to be run and the configuration and security of the machine for that reason code is partially compiled and at run time the code is compiled to machine-specific instructions or you can say binary code based on underlying operation, CPU, Machine configuration, etc. by the CLR.
1. CLS (Common Language Specification):
- CLS deals with different behaviour of the language. For Example: If I want to consume the VB.Net code inside the C#, here CLS came into picture. because C# is a case sensitive language while VB.Net is not a case sensitive language. For this CLS is set of guidelines that is used to reused the code in different programming language.
- It is a part of CLR, CLR in .NET Framework will execute all programming language code. This is possible because CLR has its own language specification (syntactical rules) which are common to all .NET Supported Programming Languages. At the time of compilation, every language compiler should follow this language specification of CLR and generate the MSIL code. This language specification of CLR is common for all programming languages and this is known as **Common Language Specifications (CLS).**
1. **What is CTS:**
- Deals with different data type of languages because every language has its own data type definition. To reuse the data inside the multiple languages we need a common type system(CTS) to compile the code in different languages.
1. **Stack and  Heap:**
- Stack and Heap are memory types in application. Stack memory stores primitive value type(Memory location and value at the same place) datatypes like int, Boolean, double, float etc. While heap stores reference type(pointer is store in the stack and actual data store in the Heap) datatypes like string and objects.
1. What is Visual Studio:

   Visual Studio is a Microsoft IDE tool that is needed to develop applications with the .NET framework. The IDE integrates 3 features 1. Editor 2. Compiler 3. Interpreter

2. What is .Net:
- .NET is a programming framework created by Microsoft that developers can use to create applications more easily. The framework provides libraries commonly used by developers. The .NET Base Class Libraries (BCL) serve that purpose.
- Programs are written for .NET Framework and execute in a software environment called Common Language Runtime (CLR).
- CLR is the foundation of the .NET framework which provides services like safety, memory management, garbage collection, and exception handling.
- CLR manages the execution of code. The code that is managed by CLR is called managed code. Unmanaged code does not get managed by CLR. CLR’s interoperability helps to interact between managed and unmanaged code.
- Common Language Specification (CLS) and Common Type System (CTS) as part of CLR. CTS is responsible for interpreting data types into a common format. CLS provides the ability of code to interact with code that is written with a different programming language.
1. What is JIT (Just in time) compilation:

   The JIT compiler translates the MSIL code of an assembly to native code and uses the CPU of the machine to execute a .NET application. It also enforces type safety in the run time environment.

2. Metadata:

   Metadata is “data about data”. It is data that provides information about other data but not the content of the data. It helps to organize, find and understand data.

3. Description of assembly.
4. Identity (name, version, culture, public key).
5. The types that are exported
6. Other assemblies that this assembly depends on.
7. Security permissions are needed to run.
8. Assembly:

   Assembly is a collection of types and resources that are built to work together and form a logical unit of functionality. It provides CLR.

   1. DLL (Dynamic link library): compilation of class library. It is a supportive file that can be compiled and reused in the application. It does not contain any main method.
   2. EXE: compilation of Application. It is an executable file we can see the output. It contains the main method.
9. Difference between Managed code and unmanaged code.

   Managed code is the code that is managed by the CLR (Common Language Runtime) in .NET Framework. Whereas Unmanaged code is the code that is directly executed by the operating system.

   Advantages of managed code:

10. It improves the security of the application like it will check whether the current has access to assembly or not and whether it is safe to execute the assembly by the Operating System or not.
11. It improves the security of the application like it will check whether the current has access to assembly or not and whether it is safe to execute the assembly by the Operating System or not.
12. It will support default exception handling.
13. Difference between IEnumerable<T> and List<T>.

   IEnumerable<T>
   - It is an Interface.
   - Can be only iterated through FOR-EACH loop.
   - Doesn’t allow random access.
   - Iterating through IEnumerable is faster compared to List.
   - Element of IEnumerable cannot be manipulated.
   List<T>
   - It is a class.
   - Can be iterated through several ways.
   - Allow random access using the integral index.
   - Iterating through Slower is faster compared to IEnumerable.
   - Element of List can be manipulated (add, remove, insert at particular index)</p>
     

14. What is Difference between static and non-static member:

- Members of a class that does not require an instance for initialization and execution
- A static variable gets initialized only once during the life cycle of a class
- The Non-Static variables are created when the object is created and are destroyed when the object is destroyed. The object is destroyed when its reference variable is destroyed or initialized with null. So, we can say that the scope of the object is the scope of its referenced variables.
- Members of a class that require an instance for initialization and execution
- non-static variable gets initialized either 0 or n number of times, depending on the number of objects created for that class.
- Static Variable scope is the Application Scope. What it means, as soon as the application start and class execution starts, static variables are created and they will be there as long as your application is running. Once the application stops, then static variables are going to be deleted.</p>
  
- Static and non-static Method in C#:
- When we create a method by using the static modifier then it is called the static method and the rest of the methods are non-static methods. You cannot consume the non-static members directly within a static method.
- If we want to consume any non-static members with a static method then you need to create an object and then through the object, you can access the non-static members. On the other hand, you can directly consume the static members within a non-static method without any restriction.
- Static and non-static constructor:
- If we create the constructor explicitly by the static modifier, then we call it a static constructor and the rest of the others are non-static constructors.
- static constructor is the first block of code that gets executed under a class. No matter how many numbers of objects we created for the class the static constructor is executed only once. 
- non-static constructor gets executed only when we created the object of the class and that is too for each and every object of the class.
1. Reason behind the ToString() method:

   All types in .Net inherit from the **System. Object** class. Because of this Inheritance, every type in .Net inherits the **ToString()** method from **System.object** class.

![](Aspose.Words.9cf1ec20-9144-491c-9ab1-78849ae8fa06.002.png)

If we have any user-defined class like the Customer class as shown in the example and when we call the ToString() method the output does not make any sense i.e., in the output you simply get the class name. 

But if we want to print the first name and last name of the customer when we call the ToString() method on the customer object. Then we need to override the ToString() method, which is inherited from the **System.Object** class.

1. Determine string represents a numeric value or not:

   we can use the **TryParse** method as shown in the example below. If the string contains non-numeric characters or the numeric value is too large or too small for the particular type we have specified, TryParse returns false and sets the out parameter to zero. Otherwise, it returns true and sets the out parameter to the numeric value of the string.

![](Aspose.Words.9cf1ec20-9144-491c-9ab1-78849ae8fa06.003.png)

1. Difference Between int.Parse and int.TryParse Method:

When we use the int.**Parse** method, if the conversion is not possible then at runtime, we will get an exception which is not a good thing. Because if conversion is not possible then we should show some information to the user whereas int.**TryParse** returns false and does not throw an exception if parsing fails. Hence int.**TryParse** is more efficient than Parse.

1. What are properties in C#:
- A Property in C# is a member of a class that is used to set and get the data from a data field (i.e., variable) of a class. 
- Property in C# is never used to store any data, it just acts as a medium to transfer the data. 
- We use the Properties as they are public data members of a class, but they are actually special methods called accessors.
- If a class contains any values in it and if we want to access those values outside of that class, then we can provide access to those values in 2 different ways either we make it public or access through the accessor.

1. Get Accessor: **[ get { return Data\_Field\_Name; } ]   ( Read-only property )**

   The get accessor is used to get the data from the data field i.e., variable of a class. Using the get accessor, we can only get the data, we cannot set the data.

1. Set Accessor: **[ set { Data\_Field\_Name = value; } ]  ( Write-only property )**

   The **set** accessor is used to set the data (i.e., value) into a data field i.e., a variable of a class. This set accessor contains a fixed variable named **value**. Whenever we call the property to set the data, whatever data (value) we are supplying will come and store inside the variable called **value** by default. Using a set accessor, we cannot get the data.

![](Aspose.Words.9cf1ec20-9144-491c-9ab1-78849ae8fa06.004.png)

1. Boxing and Unboxing:

   Boxing:

   `	`When we move a value type to a reference type, it is called Boxing. It is an implicit conversion.

   Int i = 101;

   Object obj = (object)i;

Unboxing:

`	`When we move a reference type to a value type, it is called Unboxing. It is an explicit conversion.

Object obj = 101;

i = int(obj);

**Note:** We should always need to avoid Boxing and Unboxing in C# due to performance degradation in application development.

1. Casting, Implicit casting, Explicit Casting:
- Casting means you are trying move from one data type to another data type.
- If casting is happening automatically then it is implicit casting. When you are moving from lower datatype to higher data type then the implicit casting came into picture.
- When you are moving from higher data type to lower data type then you have to do it explicitly.
- There is a problem with type casting It may be reason of data loss.
1. Difference between array and array list.
- Array is fix length size and it is strongly typed.
- ArrayList is not flexible in term of length size and not strongly typed.
- Array is better than array list and array list is slower because of boxing and unboxing.
1. Generic collection:
- It is improvement over the array and array list because Generic collection is strongly typed and flexible in a length size at the same time.
- Ex. List<> , 
1. ` `What are access modifiers in C#?

   Access Modifiers are used to control the accessibility of types and members within the types.

1. **Public:** The public type or member can be accessed by any other code in the same assembly or another assembly that references it.
1. **Private:** The type or member can only be accessed by code in the same class or struct.
1. **Protected:** The type or member can only be accessed by code in the same class or struct, or in a derived class.
1. **Internal:** The type or member can be accessed by any code in the same assembly, but not from another assembly.
1. **Protected Internal:** The type or member can be accessed by any code in the same assembly, or by any derived class in another assembly.

Interface and Inheritance:

1. Inheritance:

- Consuming the members that are defined in one class from another class. 
- We know that the class is a collection of members. And the members defined in one class can be consumed from another class by establishing a parent/child relationship between the classes.
- **Code reusability:** We can reuse the members of the parent class or base class in the child class or derived class. So, there is no need to redefine the members again in the child class. So, less code is required in the class.

1. Type of inheritance:
- Single Inheritance:

  ![](Aspose.Words.9cf1ec20-9144-491c-9ab1-78849ae8fa06.005.png)When a class is inherited from a single base class then the inheritance is called single inheritance.
   -  - 

- Multilevel Inheritance:

  ![](Aspose.Words.9cf1ec20-9144-491c-9ab1-78849ae8fa06.006.png)When a derived class is created from another derived class, then such a type of inheritance is called Multilevel Inheritance.
   -  

- Hierarchical Inheritance:

  ![](Aspose.Words.9cf1ec20-9144-491c-9ab1-78849ae8fa06.007.png)When more than one derived class is created from a single base class then it is called Hierarchical inheritance.
   -  

- Multiple Inheritance:

  ![](Aspose.Words.9cf1ec20-9144-491c-9ab1-78849ae8fa06.008.png)When a derived class is created from more than one base class then such type of inheritance is called multiple inheritance.
   -  

- Hybrid Inheritance:

  ![](Aspose.Words.9cf1ec20-9144-491c-9ab1-78849ae8fa06.009.png)Hybrid Inheritance is the inheritance that is the combination of any Single, Hierarchical, and Multilevel inheritances.
   -  

1. Why does C# not support multiple-class inheritance:

Multiple inheritance means a child class inherits data or functionality from two different parent classes which might raise the ambiguity problem. The compiler will be confused to access the function of which parent class since both of them have the same name.

1. Difference between interfaces and abstract classes.

1. Abstract classes can have implementations for some of their members, but the interface can’t have the implementation for any of its members.
1. Interfaces cannot have fields whereas an abstract class can have fields.
1. An interface can inherit from another Interface only and cannot inherit from an abstract class whereas an abstract class can inherit from another abstract class or another interface.
1. A class can inherit from multiple interfaces at the same time, whereas a class cannot inherit from multiple abstract classes at the same time.
1. Abstract class members can have access modifiers whereas interface members cannot have access modifiers as they are by default public.
1. Advantage of using interfaces.
   1. Multiple Inheritance is possible in interfaces.
   1. It allows us to develop a very loosely coupled system.
   1. Interfaces are great for implementing dependency injection.
   1. Allow separation of concern in our application.
1. Interface inherits from another interface.

   This is possible, but in that particular scenario, the child class has to implement all the methods available inside the Base interface including the derived interface. Otherwise, it will throw an error.

![](Aspose.Words.9cf1ec20-9144-491c-9ab1-78849ae8fa06.010.png)
This is possible, but in that particular scenario the child class has to implement all the methods available inside the Base interface including the derived interface. Otherwise, it will throw a error.</p>
  

1. Explicitly implementing an interface:

When a class implements the interface member using by prefixing the name of the interface, then the class is “Explicitly implementing an interface”. However, the class object has to be typecasted to the interface type to invoke the interface member.

![](Aspose.Words.9cf1ec20-9144-491c-9ab1-78849ae8fa06.011.png)

Abstract class & method  Sealed class & method:

1. What is an abstract class:

- Declared by using abstract keyword. It is a partially implemented class used for developing some of the operations that are common for all next-level subclasses. It contains both abstract and non-abstract methods. The abstract class cannot be instantiated directly. It is compulsory to create a derived class to provide the functionality of the abstract class.

1. Sealed Class:

- Whenever we want to restrict the class for inherit then we use the sealed keyword.

1. Abstract method:

- Declared with abstract modifier. It contains only the declaration and does not contain the implementation/body of the method. 

- Overriding an abstract method is compulsory.

- Generally, we use the abstract method whenever two or more sub-classes are expected to fulfil a similar type role with a different signature.

1. Use of constructor in abstract class:

In general, a class constructor is used to initialize fields we provide a constructor for an abstract class.

1. Sealed Method:

- If we don’t want to allow a subclass to override the superclass method.

- it is to ensure that all subclasses use the same superclass method logic.

1. Difference between sealed and private method.

- private method cannot be inherit whereas sealed method can be inherited but cannot be overridden.

- Private method cannot be called from sub-classes whereas the sealed method can be called from sub-classes.

1. Difference between abstract class and Sealed class:

![](Aspose.Words.9cf1ec20-9144-491c-9ab1-78849ae8fa06.012.png)

1. What are the characteristics of an abstract class in C#:

- The abstract class contain both abstract method and non-abstract(Concrete) methods.

- It can contain both static and instance variables.

- The abstract class cannot be instantiated but its reference can be created.

- If any class contain abstract methods, then it must be declared by using the Abstract keyword.

- An Abstract class cannot contain sealed methods.

- The abstract method or class cannot be declared as sealed.

- A subclass of an abstract class can only be instantiated if it implements all of the abstract methods of its superclass.

1. Explain the difference between overriding method and abstract method.
- The concept of the abstract method is similar to the concept of method overriding because in method overriding if a Parent class contains any virtual methods in it, then those methods can be re-implemented under the child class by using the override modifier.
- In a similar way, if a parent class contains any abstract methods in it, those abstract methods must be implemented under the child class by using the same override modifier.
- The main difference between method overriding and abstract method is, in the case of method overriding the child class re-implementing the method is optional, but in the case of the abstract method, the child class implementing the method is mandatory.
1. What is the need for abstract classes in application development?
- The concepts of abstract methods and abstract classes are an extension to the inheritance wherein inheritance we have been discussing that with the help of a parent class we can provide property to the child class that can be consumed by the child classes which gives us re-usability.
- Along with the parent providing property to the children, the parent can also impose the restriction on the children with the help of abstract methods so that all the child classes have to full fill the restriction without failing.

Polymorphism 

MVC

- What is the benefit of using ASP.Net Core over ASP.Net?

- What is MVC(Model View Controller)?
- It is an architectural design pattern; the Model View Controller is the main component of MVC.
- The main objective of the MVC design pattern is the separation of concern. It means the domain model and business logic are separated from the user interface(View). Thus, maintenance and testing of applications become easier. 
- Model is responsible for data; View is responsible for UI(User Interface) and Controller is responsible for the flow of the application.
- Controller.
- Controller is a special .cs class that inherits the inbuilt controller class.
- It is used to handle an incoming HTTP request and contains action methods.
- It is the one that will interact with both view and model in order to control the flow of the application.
- By Default, controllers are available inside the controller folder.
- Model:
- Model is basically a C# class used to manage the business data and business logic.
- It can be accessed by both the controller(to pass the data to a view) and the view(to display the data to the user).
- View:
- It is responsible for displaying the data to the user. By default, views are stored inside the Views folder.
- View is nothing but the cshtml file which is a combination of C# and HTML files.
- A view request can be made from the controller’s action method only.
- Advantage of using ASP.Net Core MVC:
- It is much faster compared to Asp.Net MVC. It is a cross-platform framework you can use to build web applications that can run on Windows, Linux, or macOS.
- As we are separating the view from the rest of the application which enables us to change of view in the future without affecting the rest of the application.
- Separation of concern, it is divided into three major components (Model, View, Controller) which make it easier to manage the application complexity.
- Provide better support for test-driven development(TDD).
- Program.cs class:

![](Aspose.Words.9cf1ec20-9144-491c-9ab1-78849ae8fa06.013.png)

- This is the entry point of the application, Inside the Program.cs class we have the main method. This is the method from where the execution starts.
- Host Builder:
- Host Builder is a static class that provides two methods (CreateDefaultBuilder) when we call these, they will add some features to Asp.net core applications. One method without a parameter and the other method takes a string array as an argument.
- The Host Builder provides two methods for creating instances of pre-configured IHostBuilder(Interface) which is available inside the Host class.
1. Host:
- Host is a static class that can be used for creating an instance of IHostBuilder pre-configured defaults.
1. CreateHostBuilder ():
- The CreateHostBuilder () method is responsible for configuring and creating an instance of the IHostBuilder which is used to set up the web host for the application. The web host is the environment in which the application runs, managing requests, services, configuration, logging, and more.
- This is nothing but a name of method we can also use any name instead of CreateHostBuilder ().
1. CreateDefaultBuilder(): 
- It is available inside the Host class.
- By using the CreateDefaultBuilder method we will get the in-built support of dependency injection.
- It loads app configuration from “appsettings.json” and “appsettings.[EnvironmentName].json”, configuration is nothing but the settings that our application uses.
- Used to setup the default logging support for us into the application.
- Load configuration from environment variables.
- This method is use to read the environment variable.
- Set the default path of the application.
1. ConfigureWebHostDefaults():
- This is the actual method that convert a console application into the web application.
- It is use to configure a HostBuilder with defaults for hosting a web app.
- Enables the IIS Integration and kestrel server.
- Also add the ForwardedHeaders middleware if ASPNETCORE\_FRWARDEDHEADERS\_ENABLED=True.
1. webBuilder:
- The WebHostBuilder is typically used in the Program.cs file of an ASP.NET Core application to configure various aspects of the web application, such as setting up the server, configuring services, and defining how requests and responses are handled. It's part of the process of setting up and "building" your web application.
- Because with the help of web builder here we are calling the Startup class.
- Startup class:
- With the help of this class, we can configure the environment in our ASP.net Core application. We can use Constructor and two different methods: ConfigureServices and Configure for setting up the environment. This class creates services and injects services as dependencies so the rest of the application can use these dependencies. The ConfigureServices used to register the service and Configure method allow us to add middleware and services to the HTTP pipeline. This is the reason ConfigureServices method calls before Configure method.
- The startup class can be configured using UseStartup<T>() extension method at the time of configuring the host in the main method.
- It contains all the information regarding the configuration and hosting the ASP.Net Core application.
1. ConfigureServices() Method:
- We can add services to DI container using this method.
- It is used to configure services that are used by the application.
- This method must be declared with a public access modifier so that environment will able to read the content from metadata.
1. Configure() Method:
- This method is used to define how the application will respond on each HTTP request i.e., we can control the ASP.net pipeline.
- It is also used to configure Middleware  into the application http line.
- Whenever any service is added to ConfigureServices method, it is available to use inside the Configure method.
- Inside the Configure() Method we have some middleware let’s understand one by one.
1. HTTP Pipeline and Middleware:
- It is responsible for handle all the requests and responses of the application. 
- All the request goes through the http pipelines.
- http pipeline is combination of multiple Middleware.
- A Middleware is a piece of code (Software component) that is used in the HTTP pipeline.
- Generally, before actually hitting to the controller we have a separate path or component, where we have to define lots of middleware and this middleware has access to all those request and responses that are made to the particular application.
- We do not hit controller directly from the http pipeline because logic and data available inside the controller. so, we have to perform some tasks for that we use the middleware’s. Middleware validates all the request and if it is a valid request then it will forward to the next step otherwise it will send back the request that is called short circuiting.
1. App.UseRouting():
- It enables the routing into our application.
1. Routing:
- It is used to inspect the http request and then map that http request to the controller’s action method.
1. Conventional Routing:
- It is default routing behaviour which application follows, in this first look for the controller then action method. According to URL received by the user.
1. Attribute Routing:
- Attribute routing allows us to define routes directly on our controller and action methods using the **Route** Attributes.
- It gives us more control over the URLs by defining routes directly at action methods or Controllers in our Asp.Net Core application.
- With Attribute Routing, we can specify route templates for individual action methods.
1. MapGet and Map:
- In ASP.NET Core MVC, the Map and MapGet methods are used to configure routing for specific HTTP methods and paths.
- Map is general purpose method which are applicable for various HTTP verbs(Get, Put, Post, Patch, and Delete).
- But MapGet is applicable for a specific type of HTTP verb(Get) only. 

1. MapDefaultController Route method:
- This method is used to map the endpoints by default to home controller and index method. Suppose instead of using home controller you are using other controller and instead of using index method you are using other main action method. In that scenario you have to tell your application explicitly that you are using this new controller and action method by using some other method.
- LaunchSettings.json file:
- The launchSettings.json file is a configuration file in ASP.NET Core MVC applications that is used to specify settings related to how the application should be launched and debugged in different environment. And how the application should behave during development.
- It is a Json file that contain profile for different environment each profile represents a set of settings for running and debugging the application.
- Environment Variable:
- It is used to configure the application based on the current profile. 
- It is use to determine whether application should run in a development or production. 
- Type of environment:
  1. Development
  1. Staging
  1. Testing
  1. Production(Prod)
- AppSettings.json file
- It is a Json file that allows you to store and centralize various configuration settings at one place. It includes Database Connection String, API keys, logging settings, and more.
- Logging:
- Logging is a process in software development, in this we record and stored information about what a program is doing at runtime. This information can include various events, errors, Warning, and other messages that helps developers and administrators to understand how an application is behaving.
- What is the difference between 3-layer architecture and MVC architecture?
- The 3-layer architecture separates the application into 3 components which consist of the Presentation Layer,** Business Layer, and Data Access Layer. In 3-layer architecture, the user is going to interacts with the Presentation layer only. 3-layer is a linear architecture.
- The MVC architecture separates the application into three major components such as Model, View, and Controller. In MVC architecture, the user is going to interacts with the controller with the help of a view. MVC is a triangle architecture.
- MVC does not replace 3-layer architecture. Typically, MVC and 3-layer architecture are used together and the MVC Design Pattern acts as the Presentation layer of the application.
- Can you please explain the request flow in the ASP.NET Core MVC framework?
- In the ASP.NET Core MVC application when the client makes a request (i.e., HTTP Request) for a resource from the browser then that request is first Received by the Routing Engine. Once the Routing engine receives the HTTP Request, then it figures out the URL Pattern of the incoming request and checks if that URL pattern is present in the Route table. If there is no matching URL Pattern found in the routing table for the incoming HTTP request URL Pattern, then it simply returns a 404 HTTP status code to the client. If it found a matching URL pattern for the incoming request in the Route Table, then it fetches the corresponding handler information and forwards the request to the appropriate controller and action method.
- The controller then plays its role and executes the action method. While executing the action method if needed then it will work with the model component in order to serve the request. Once it works with the model component, then it selects a view and passes that model data to that view, and that view will transform the model data and generates an appropriate response that is rendered to the client.
- What are Action methods in ASP.NET Core MVC?
- Controller actions are methods defined in the controller class and responsible to perform required operations on the user’s inputs like form values, query strings values, etc. with the help of the Model and passing the results back to the View.
- What is ActionResult and how is it different from others?
- The ActionResult class is the base class for all action results. An action result can be of type ViewResult, JsonResult, RedirectResult and so on. Hence, when your action method returns multiple results based on different conditions, ActionResult is the best choice. Since it can return any type of result.
- How to make a non-Action method in ASP.NET MVC?

By default, the ASP.NET MVC framework treats all public methods of a controller class as action methods. If you do not want a public method to be an action method, you must mark that method with the NonActionAttribute attribute.
![](Aspose.Words.9cf1ec20-9144-491c-9ab1-78849ae8fa06.014.png)
  

- Can you change the action method name?
- We can also change the action method name by using the ActionName attribute. Now action method will be called by the name defined by the ActionName attribute.

![](Aspose.Words.9cf1ec20-9144-491c-9ab1-78849ae8fa06.015.png)

- Now, DoSomething action will be identified and called by the name DoAction.
- How to restrict an action method to be invoked only by HTTP GET, POST, PUT or DELETE?
- By default, each and every action method can be invoked by an HTTP request (i.e., GET, PUT, POST, and DELETE). But you can restrict an action to be invoked only by a specific HTTP request by applying HttpGet or HttpPost or HttpPut or HttpDelete attribute.
- If you want to restrict an action method for HTTP Get request only then decorate it with HttpGet action method selector attribute as given below:

![](Aspose.Words.9cf1ec20-9144-491c-9ab1-78849ae8fa06.016.png)

- What are Partial Views in ASP.NET Core MVC and it’s needed?
- A partial view is like user control in ASP.NET Webforms that are used for code re-usability. Partial views help us to reduce code duplication. Hence partial views are reusable views like Header and Footer views. We can use the partial view to display blog comments, product category, social bookmarks buttons, a dynamic ticker, calendar, etc.
- It is best practice to create a partial view in the shared folder and the partial view name is preceded by “\_”, but it is not mandatory. The “\_” before view name specifies that it is a reusable component i.e., partial view.
- What are the Layouts in ASP.NET Core MVC?
- A layout is a .cshtml file that is used to provide common structure to other views.
- You can use a layout to define a common template for your site**.** 
- Layouts are used to maintain a consistent look and feel across multiple views within the ASP.NET MVC application. As compared to Web Forms, layouts serve the same purpose as master pages but offer a simple syntax and greater flexibility.
- RenderBody: 
- It is used inside layout file to provide space for other view and we can have only one Render Body method inside one layout file.
- RenderSection:
- Render section is a space with a specific name and it used on \_Layout file.
- Render section tells the application that some other code ( coming from view ) will be placed here.{So whatever place we will define inside the \_Layout file that place will be replaced by some other code that is coming from other views}.
- \_ViewStart.cshtml file:
- Whenever we will run the application, this is the first file which will execute before any view file which is available in our application. 
- It means instead of defining the code that is required for each view you can define that code here into this common \_ViewStart.cshtml file.
- As we know we can use the \_Layout.cshtml file for common code of View. and we have to mention that particular common \_Layout.cshtml file for each View separately.
- If we mention that \_Layout.cshtml file inside the \_ViewStart.cshtml file, then the \_Layout.cshtml file will apply on each View Automatically. No need to mention the \_Layout.cshtml file to each view, Because I already told you \_ViewStart.cshtml file is the first View file which will render after running the application.
- \_ViewImport.cshtml:
- You can see that a Namespace is used at top of the code. here you are repeating the code, it means you are not following the good architecture. And to manage this code repetition you need a one new file in Asp.Net Core application named \_ViewImports.cshtml.
- All the common directives that we are going to used inside our application that we can write over here.
- The main purpose of using this \_ViewImports.cshtml file is to create a centralized place for all the directives that you are using into the application.	
- ViewBag:
- ViewBag is used to pass data from action method to view and we can display this data on view.
- We can pass any type of data in ViewBag.
- It is a dynamic property.
- Its life lies only during the current request.
- If redirection occurs then its value becomes null.
- It doesn’t require typecasting for getting data.
- ViewData:
- ViewData is also used to pass data from action method to view and we can display data on view.
- The type of data binding is known as loosely binding.
- We can pass any type of data in view data.
- View data use ViewDataDictionary.
- Its life lies only during the current request.
- If redirection occurs then its value becomes null.
- It’s required typecasting for getting data and check for null values to avoid the error.
- TempData :
- TempData is used to transfer data from the view to the controller, the controller to the view, or from an action method to another action method of the same or a different controller. 
- TempData temporarily saves data and deletes it automatically after a value is recovered.
- Session:
- In ASP.NET Core MVC, sessions are a mechanism for storing and managing user-specific data on the server side across multiple HTTP requests for a given session
- A session is responsible for storing user data in the web server when browsing a web application. In general, web applications operate on the stateless HTTP Protocol, where each HTTP request is independent.
- Authorization: 
- Authorization is a security mechanism used to determine whether the user has access to a particular resource or not.
- Validation: 
- It is used to validate the data that we are getting from the request and in .NETCore we can implement the validation by using data annotation.
- Tag Helpers: 
- Tag helpers are used to render server-side code on a Razor (.cshtml) file to create and render html elements.
- It is basically a concept by using this we can combine html and the C# code by using Tag Helpers you will get lots of functionalities you can even enhance the functionalities of your html elements and you will get the robust and fast application.
- It is use to simplifies the process of generating elements in views.
- Memory Cache: 
- It Is used to store something in memory that is being used frequently to provide better performance.
- Filter and types of filters in .Net Core MVC application.
- The Filters in ASP.NET Core MVC Framework are the attribute that allows us to inject some logic or code which is going to be executed either before or after an action method is invoked.

Types of filters:

- Authentication Filter (Introduced in MVC 5)
- Authorization Filter
- Action Filter
- Result Filter
- Exception Filter

  Note : 

  This is also the order of the execution of Filters if more than one filter is applied. But the point that you need to remember is the Exception Filter can be executed at any point in time when there is an unhandled exception occurred in your application.

- we can also create custom filters in MVC. If the built-in filters do not serve our purpose, then we can create our own custom filter as per our business requirements. We can create the Custom Filter for all the five categories (Authentication Filter, Authorization Filter, Action Filter, Result Filter, and Exception Filter) of Filters.
- We can configure our filter to three different level
  1. Global Level (Applicable to all controllers and all action methods)
  1. Controller Level (Applicable to all the action methods of the particular controller)
  1. Action Level (Applicable to the specific action methods)
- Child Action in Asp.net Core MVC:
- Suppose you have a scenario where you have one action method and you don’t want that action method to be invoked via URL rather you want that action method to be invoked by other actions of your application. Then in such scenarios, **ChildActionOnly Attribute** can be handy. 
- So, when we decorate an action method with the ChildActionOnly attribute, then it is called child action method.
- The child action methods will not be responded to incoming URL requests. If you try to invoke the child actions using URL, then you will get a runtime error saying – Child action is accessible only by a child request.
- You can only access the child action methods by making a child request from a view either by using the “Action()” or “RenderAction()” HTML helper methods.
- an action method doesn’t need to have the **ChildActionOnly** attribute to be used as a child action. You can access the normal action methods by making a child request. You need to use the **ChildActionOnly** attribute only if you want to prevent the action method to be invoked using URL.
- Partial View:
- We need to develop a partial view when we need a common part of the user interface on multiple pages in a web application. A partial view is a regular view that can be used multiple times in an application.
- Sometimes we also use a partial view to divide a web page into small parts such as header, footer, and menu on Layout.
- Whenever we use Partial Views, it must be rendered as a child view.

Web API

- Dependency Injection (DI):
- It is a design pattern used in software development, including .NET Core, to manage how components (objects or services) depend on each other. It's a way to provide the necessary dependencies to a class from the outside rather than having the class create them itself. It promotes loose coupling.
- Here are the key characteristics of the Singleton pattern:
- Only one instance created once for entire application and allowing other part of the code to easily access it.
- **Single Instance**: The Singleton class guarantees that there is only one instance of itself in the entire application.
- **Global Access**: It provides a global point of access to that single instance, allowing other parts of the code to easily access it.
- **Lazy Initialization**: The instance is created only when it's first requested, not when the program starts. This helps optimize resource usage.
- **Thread Safety**: Properly implemented Singleton patterns are thread-safe, meaning they can be safely used in a multi-threaded environment without causing issues.
- Transient Lifetime:
- New instance is created for every request at every place. And same instance is not reused.
- In the Transient lifetime, a new instance of the service is created every time it is requested. This means that every time you ask for the service, you get a fresh instance. Transient services are not shared; they are created a new for each request.
- Scoped Lifetime:
- New instance created once for every (round trip) http request and can be reused.
- In the Scoped lifetime, a new instance of the service is created once per client request. The same instance is reused within the scope of a single client request, but different requests will have different instances. This is typically used in web applications to ensure that the same instance is available throughout the duration of a single HTTP request.
- Dependency Injection:
- It is a technique to achieve IOC(Inversion of control – It means you need to make your loosely coupled so that in future there is any change then there should not be any tightly coupling between two classes or objects they should have loosely coupling and that is the main agenda of inversion of control that is loosely binding)

Problem if we do not use DI:

- Suppose I am working on a web application and I have created few controllers. Suppose I have five controller file asp.Net Core web application in general when you working on a large project then you can see there are more than five controllers in your project.
- Suppose in this application you are using some services in our case we are using repository, and we are using those repositories into our controller class and this concept is not fixed only for controller and repository. it is applicable for two classes, if you are going to use two classes in each other then you need to use dependency injection.
- Difference between synchronous and asynchronous programming:
- Synchronous programming involves executing code in a sequential manner, while asynchronous programming involves executing code in a non-blocking manner. In Asp.Net Core, asynchronous is typically used to improve the responsiveness and scalability of web application.

Entity Framework Core :

- Entity Framework Core:
- It is a Microsoft technology to interact with relational database.
- Generally, we need a middle service which is compatible to work with database and application as well.
- Features of Entity Framework Core:
- ORM: It is a tool that is used to manage the database data from an object-oriented perspective.
- Open source
- Light weight
- Extensible
- Support Async

Object-Oriented perspective:

- Database Tables => Classes
- Column => Properties
- Code-First approach: {first you will create classes and properties and from these classes you can generate your database automatically} or 
- Database-First approach: {First you are working on a database then from that database you are creating classes}
- DbContext Class:
- It works as a bridge between your C# code and the underlying database.
- It is like a manger that helps you to interact with database, allowing you to query and manipulate data.
- It helps you define your data models, configure the database connection, and provides methods to interact with the database, making it easier to perform database operations in your C# application.
- DbSet property:
- It simplifies database access by allowing you to work with entities and perform CRUD (Create, Read, Update, Delete) operations in a more natural and object-oriented way.
- It is part of DbContext class and serve as an entry point for manipulating data in a specific database table.
- 
**SQL**

1. What is RDBMS:
- Relational Database Management Systems (RDBMS) are database management systems that maintain data records and indices in tables. Relationships may be created and maintained across and among the data and tables.
- In a relational database, relationships between data items are expressed by means of tables.
1. Explain DML, DDL, DCL and, TCL:
- DML(Data Manipulation language) 
- used to retrieve, insert, update, and delete data in a database.
- These are basic operations we perform on data such as selecting a few records from a table, inserting new records, deleting unnecessary records, and updating/modifying existing records.
- **SELECT** – select records from a table.
  **INSERT** – insert new records.
  **UPDATE** – update/Modify existing records.
  **DELETE** – delete existing records.
- **DDL(Data Definition Language)**
- DDL statements are used to alter/modify a database or table structure.
- **CREATE** – create a new Table, database, schema.
  **ALTER** – alter the existing table, column description.
  **DROP** – delete existing objects from a database.
- **DCL(Data Control Language)**
- we will use these commands to secure database objects by creating roles, permissions using GRANT, REVOKE operations.
- **GRANT** – allows users to read/write on certain database objects.
  **REVOKE** – keeps users from the read/write permission on database objects.
- **TCL(Transactional control language)**
- TCL is used to manage transactions within a database.
- Examples: COMMIT, ROLLBACK, Begin Transaction statements.
- **BEGIN Transaction** – opens a transaction.
  **COMMIT Transaction** – commits a transaction.
  **ROLLBACK Transaction** – ROLLBACK a transaction in case of any error.
1. Difference between Drop Delete and Truncate Statement in SQL Server:
- Delete:
- The DELETE command is used to remove some or all rows from a table.
- A WHERE clause can be used with a DELETE command to remove some specific rows from a table.
- If the WHERE condition is not specified, then all rows are removed.
- Delete Command is slower than Truncate.
- Truncate:
- TRUNCATE removes all rows from a table, but the table structure and its columns, constraints, indexes, and so on remain.
- It does not require a WHERE clause, so we cannot filter rows while Truncating.
- Drop:
- The DROP command removes a table from the database.
- All the related Data, Indexes, Triggers, Constraints, and Permission specifications for the Table are dropped by this operation.
1. Difference between Primary key and unique key.
- A table can have only one primary key. On the other hand, a table can have more than one unique key.
- The primary key column does not accept any null values whereas a unique key column accepts one null value.
### By default, the primary key creates a unique clustered index on the column whereas a unique key creates a unique non clustered index.
1. Normalization:
- In relational database design the process of organizing data to minimize redundancy. Normalization usually involves dividing a database into two or more tables and defining relationships between the tables.
- The objective is to isolate data so that additions, deletions, and modifications of a field can be made in just one table and then propagated through the rest of the database via the defined relationships.
- Different form of Normalization:
1. **1NF (Eliminate repeating groups):** Make a separate table for each set of related attributes, and give each table a primary key. Each field contains at most one value from its attribute domain.
1. **2NF (Eliminate Redundant Data):** If an attribute depends on only part of a multi-valued key, remove it to a separate table.
1. **3NF (Eliminate Columns Not Dependent on Key):** If attributes do not contribute to a description of the key, remove them to a separate table. All attributes must be directly dependent on the primary key
1. **BCNF (Boyce-Codd Normal Form):** If there are non-trivial dependencies between candidate key attributes, separate them out into distinct tables.
1. **4NF (Isolate Independent Multiple Relationships):** No table may contain two or more 1:n or n:m relationships that are not directly related.
